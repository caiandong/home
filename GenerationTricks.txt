1.在使用模板写二叉树结点，即在模板类中写嵌套模板。也可以利用外边的模板参数T而写正常的嵌套类。
2.红黑树中某个节点x是黑色，并且它的兄弟节点y是红色，则其他包括y的孩子，以及xy共同的父节点都是确定
	的黑色。那么此时对y以及父节点p进行旋转(左旋或右旋)，则只需要反转y与父节点p的颜色，红黑树性质不变。
3.java中内部类作用除了封装隐藏，还类似于每个外部类的方法。它可以通过实现接口来实现c++中函数符的用法，还可以用来回调。
	方法和作用域中的内部类还可以用来实现lambda表达式，并且在这个作用域包括函数作用域内声明的变量必须是final，
	否则作用域结束后，这些变量不复存在，但内部类的生命周期一般不会结束，因此无法改变这些变量。
4.函数节流与防抖
    基本上把接受的密集型事件放到一个抽象的代理层,拦截这些事件,然后设置一个定时器决定如何处理,有两种方式:
    1.节流:设置一个稍后调用的延时的只会调用一次的计时器,例如200ms,在这段期间内如果有接受事件则把之前的取消,重新设置一个计时器.
    2.防抖:不过当新的事件触发时,也设置一个200ms的同样的计时器,如果发现当前计时器已存在,则忽略事件.
5.c中指针和数组.数组是仅仅一块内存区域,其它都是依赖于指针操作的,所以数组和指针真正只有这一点不同.因此,任何时候把一个数组传递成指针表示时,它必须反向
    可以还原成本身数组.如此简陋的实现都是为了速度.
6.tcp三次握手四次挥手
    因为建立连接时,两者都希望尽快建立连接,所以服务端确认连接的同时可以回送SYN+ACK.
    而断开连接时,两者是不对等的,每一方都有自己的数据要发送.
    就像两个人结婚容易离婚就复杂些.
7.对象-构造函数-原型
    讲述一个悲惨的故事.
        小明的爸爸出于不明原因死掉了,他妈妈重新找了个男人,然后小明每次喊爸爸就是这个继父.
    小明相当于调用构造函数产生的对象,他妈妈是构造函数,继父是原型.
    这个例子不太恰当,因为构造函数可以产生任意多个对象.
    这里说明的问题是,小明妈妈与继父是构造函数和原型的关系,小明与继父类似于对象中隐含的指向原型的指针和原型.
    构造函数与它的原型,分别只关注各自的事情,构造函数负责类型,原型负责方法.
8.var和let
    var在对应的环境中声明一个变量,即全局执行环境和函数执行环境.
        当运行对应js代码之前时,解释器先要在执行前取得相应的准备.包括但不限于获取函数声明和var声明,并且使用var声明的多个名字相同的变量被视为一个.
        然后当执行时,按照代码中的相对位置初始化和赋值.变量提前只是不愿说清底层概念而采取的敷衍说法,很容易让人困惑.
    let在块作用域声明变量.考虑es6转换成es5代码,可以看作是使用了一个匿名闭包构造一个临时环境,并且立即执行,之后环境中的变量会被销毁.
    也就是说,解释器并不对let做特殊处理,并且有意限制声明不允许提前.
