
## java泛型（更多理解，第一次修正）
  
  oracle官网java文档中说明了引入泛型是为了使代码更加安全，更少出bug，把更多的安全检查放在编译时期，以及
  代码健壮型可维护性诸多好处。它采用和"泛型"一样的形式,也就是携带类型参数，对于没有接触泛型的人来说可能不知道我在
  说什么。如果你了解c++的泛型，你也会在学习java泛型时遇到一样的困惑以及提到“泛型”这个词时敏感到关注它的形式。
  
  在c++中泛型却被称为模板，在编写一个模板时你只是在把你想创建的函数或者类的想法告诉编译器，当编译时，编译器根据
  实际的类型参数帮你生成对应各自的函数和类。在编写模板时编译器并不会协助你多少，并且它会拒绝帮助你对你的模板作任何揣摩或者
  选择。等到真正生成函数时出错，它就反过来把所有的错误抛给你，让你自己来背锅。
  所以你在编写不太复杂的模板时能够随心所欲，特别是你基本上不用关注你泛型参数的类型，而且它的清晰性可读性非常高，
  因为所有的泛型参数都是一个占位符，你只要专注于描述你的想法，不用关注这些参数。然而，但也危机四伏，除非你保证不出错。
  并且面对模板时dubug难以调试。
  
  自然而然我们对泛型会有这样一种印象：广泛的类型都可以，主要他们能按照描述的方式正确工作就行。
  
  于是到了java中，这样的经验反而使你处处碰壁。首先，你的泛型参数是假的，编译器用来隐瞒它的真实目的的手段而已。因为看上去你可以不用关注参数，
  但它什么也做不了，只是object，就像医院里的植物人，只能呼吸与吃饭。所以你必须用边界来限定参数具有什么行为，你也要假定你的泛型参数是继承于什么样的
  类，但这并不是欺骗编译器，因为实际运行时，编译器只根据你的类来作为依据，而即使你的类型拥有那种行为但并不是那个类的类型，都会遭到拒绝。
  泛型的参数成了限制的类型。于是类型安全性得到编译时保证。
  

## 引用

java中引用是一种类型，c++中是一种概念。
java中引用只能赋给对象，c++中可以引用所有类型（引用不是类型）。


## java中lambda表达式

和匿名内部类一样，可以访问其所在外围类。但是在其被定义处的函数作用域的变量是不可改变的，由于lambda会以接口形式逃出作用域，所以在函数作用域外，
函数内的变量（包括函数参数）会被销毁，所以事实上无法改变任何引用以及基本类型。
javasript是动态类型，闭其包可以被外部变量引用。c++中lambda本身无法逃出定义处作用域。

## java泛型

java1.5在没有泛型之前，

## java泛型

  java中泛型稍微深入理解下是极其令人困惑，对于已有泛型的使用上来说，还算可以接受。
  极端来说，其引入有点像垃圾收集器的作用，大概就是编译器会说：哥们，我不认为你可以记住你的的代码中Object类型的参数，
  并且我也不相信，即使你告诉每一个使用你代码的人，他们能记住传入你的指定类型。

  c++中，我们可以很容易让类或函数参数化为模板，泛型参数使得不同类型的相同代码逻辑统一为单个模板，
代码的核心抽象程度更高，进而增加代码复用性。这背后的工作由编译器`具体化`完成。当然c++中编写泛型并不是件容易事，并且泛型开辟了c++中非常重要的领域。

  泛型于java5才被添加到java中，然而不像听上去那样“`泛型`”（java中泛型不该起一个那么令人困惑的名字，泛型限定可以吗）即“泛化参数类型”，在泛型的使用上，
特别是编写上，是不那么容易的。泛型最大的成就是让类型不安全的代码在编译时期得到保证。这是令人沮丧的，我们加入泛型不是为了写更少，更通用的代码，
仅仅是为了告诉编译器，让他们放心，我们的代码是类型安全的。为了兼容以前代码，我们的泛型参数在运行时被擦除为Object，因而在运行时无法获得参数类型，
因此在编译时期对泛型极其严格小心，这很大程度上约束了泛型的表述能力。

  在c++中编写泛型，即模板，是非常简洁明了，你只需要把你不确定的类型替换为泛型，当你传入具体类型时，
  编译器就默默把类型匹配上，从而最终生成一个特定类型模板实例（真正要使用的类）。
  
  在java中编写泛型，你既当爹又当妈，必须告诉编译器参数边界，泛型参数才能有某种行为，并且这个类（或者方法）就是披了泛型外衣真正参数为Object的普通类。
  
  举个不恰当的列子，当你想要去北京，在c++中，你只需要告诉编译器你想去北京，你就会得到一张票，在java中，你不但要决定车票的时间，价格，还要亲自去取票。
## 递归的讨论

在对问题的描述上，最开始的思考事实上是递归。循环应该是对递归实现上的一种选择。一般的函数利用栈空间都可以直接把递归描述实现出来，循环反而成为了某些递归的（像是尾递归）一种优化方式。

递归的编写上通常有两个步骤：

1把较大问题描述成为较小的相同本质的一个或多个子问题与额外操作，然后继续对子问题作同样的处理

2到达基准情况

相同本质的意思大概有点像：除了规模不同，否则完全无法区分这些问题。

递归正确性原因大概是数学归纳法。
## 循环

循环的本身的意义应该是：除了时间以外，所有的一切都又和之前的某个时间开始一样。通常，如果我今天下午6点看了电影：肖申克的救赎，而明天下午同样6点，我又看了
它……没完没了。隐含的周期是24小时。

以这样的看法来看待程序中的循环，反而不太严谨，因为每次循环的内容调整过之后，和原本并不像同，反而更像递归，那就把它称作 
程序循环吧。

编写程序循环的要点需要找到某一时间点，那就叫某个状态，这个状态就是和递归的 相同本质 意思差不多。于是在每一次循环后到下一次循环前之间，要保证
这些状态不变，一般就是包括元素之间关系。循环结束就是状态中元素关系不成立了。
## 优化


