## java中lambda表达式
和匿名内部类一样，可以访问其所在外围类。但是在其被定义处的函数作用域的变量是不可改变的，由于lambda会以接口形式逃出作用域，所以在函数作用域外，
函数内的变量（包括函数参数）会被销毁，所以事实上无法改变任何引用以及基本类型。
javasript是动态类型，闭其包可以被外部变量引用。c++中lambda本身无法逃出定义处作用域。
## java泛型

  java中泛型稍微深入理解下是极其令人困惑，对于已有泛型的使用上来说，还算可以接受。
  极端来说，其引入有点像垃圾收集器的作用，大概就是编译器会说：哥们，我不认为你可以记住你的的代码中Object类型的参数，
  并且我也不相信，即使你告诉每一个使用你代码的人，他们能记住传入你的指定类型。

  c++中，我们可以很容易让类或函数参数化为模板，泛型参数使得不同类型的相同代码逻辑统一为单个模板，
代码的核心抽象程度更高，进而增加代码复用性。这背后的工作由编译器`具体化`完成。当然c++中编写泛型并不是件容易事，并且泛型开辟了c++中非常重要的领域。

  泛型于java5才被添加到java中，然而不像听上去那样“`泛型`”（java中泛型不该起一个那么令人困惑的名字，泛型限定可以吗）即“泛化参数类型”，在泛型的使用上，
特别是编写上，是不那么容易的。泛型最大的成就是让类型不安全的代码在编译时期得到保证。这是令人沮丧的，我们加入泛型不是为了写更少，更通用的代码，
仅仅是为了告诉编译器，让他们放心，我们的代码是类型安全的。为了兼容以前代码，我们的泛型参数在运行时被擦除为Object，因而在运行时无法获得参数类型，
因此在编译时期对泛型极其严格小心，这很大程度上约束了泛型的表述能力。

  在c++中编写泛型，即模板，是非常简洁明了，你只需要把你不确定的类型替换为泛型，当你传入具体类型时，
  编译器就默默把类型匹配上，从而最终生成一个特定类型模板实例（真正要使用的类）。
  
  在java中编写泛型，你既当爹又当妈，必须告诉编译器参数边界，泛型参数才能有某种行为，并且这个类（或者方法）就是披了泛型外衣真正参数为Object的普通类。
  
  举个不恰当的列子，当你想要去北京，在c++中，你只需要告诉编译器你想去北京，你就会得到一张票，在java中，你不但要决定车票的时间，价格，还要亲自去取票。
## 递归的讨论

在对问题的描述上，最开始的思考事实上是递归。循环应该是对递归实现上的一种选择。一般的函数利用栈空间都可以直接把递归描述实现出来，循环反而成为了某些递归的（像是尾递归）一种优化方式。

递归的编写上通常有两个步骤：

1把较大问题描述成为较小的相同本质的一个或多个子问题与额外操作，然后继续对子问题作同样的处理

2到达基准情况

相同本质的意思大概有点像：除了规模不同，否则完全无法区分这些问题。

递归正确性原因大概是数学归纳法。
## 循环

循环的本身的意义应该是：除了时间以外，所有的一切都又和之前的某个时间开始一样。通常，如果我今天下午6点看了电影：肖申克的救赎，而明天下午同样6点，我又看了
它……没完没了。隐含的周期是24小时。

以这样的看法来看待程序中的循环，反而不太严谨，因为每次循环的内容调整过之后，和原本并不像同，反而更像递归，那就把它称作 
程序循环吧。

编写程序循环的要点需要找到某一时间点，那就叫某个状态，这个状态就是和递归的 相同本质 意思差不多。于是在每一次循环后到下一次循环前之间，要保证
这些状态不变，一般就是包括元素之间关系。循环结束就是状态中元素关系不成立了。
## 优化


