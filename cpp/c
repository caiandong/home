
函数指针和函数名
    函数名表示指向函数的地址.假如使用typedef定义一个函数类型
        typedef char  * fn(int );
    那么在某个函数声明中 ,我们可以声明这样一个函数指针
        void f(fn * pf);
    令人疑惑的是也可作以下声明
        void f(fn pf);
    这两者行为却是一样的,不太明白.
    
    每个变量的定义都描述了三件事:
        1.变量类型
        2.变量标识符名
        3.变量的具体定义
    例如
        int a;  //int表示类型,a是标识符,具体定义由编译器分配一块int大小内存.
    同样
        char * f(){}   //char * $()表示类型,f是标识符,{}由编译器分配函数体内的代码空间.
    但函数不同点在于其定义必须在任何函数之外定义.
        


指针和数组只有一点是相同的，
    1.数组名等于数组中第一个元素的地址。 
所以诸如
    int (*p)[2]=a[3][2];
是正确的，因为p是一个指向两个元素数组的指针，数组名a就是这些两个元素数组的指针所组成的三个数组中的第一个指针。
除此其他几乎数组和指针没有什么关系
    
注意:char * * p等价于 char * a[];具体原理按照如上分析，

我们可以同时在char * *p==char * a[]两边加上*或者[]，而不能分别加上*和[]。例如下面是合法的
    char * (*p)[x]==char * a[][x]
    或者
    char * * *p==char * * a[]
因此
    p==a    //数组名等于第一个元素地址
    *p==a[0];   
    *a==a[0]
    *p==p[0]    //指针可以当做数组使用

传递某个变量a的地址给一个指针p，
    type * p=&a;
那么使用 *p 进行赋值操作时相当于把a从本来的位置带到了p所在的位置，即对a赋值。

========我们可以使用地址来近似数组,却不能以数组近似指针=====
如果某个数组是n维数组,则解n次引用(事实上这种操作就是原地对当前地址的不同解释罢了)得到数组首元素的值,这可以是任何诸如int char的基本类型,或者自定义的struct
相反对于n层指针,解n次引用,是在各个地址上来回穿梭,地址之间不是同一个地址,甚至基本上不在连续内存空间内
    所以
        int p[][][][] 只等价于第一层替换，即int (*P)[][][]  
            但不等价于int * * * *p
        int * * * *p等价于 int * * * p[]
    注意:这里貌似*操作符对于数组和指针的行为是不同的,这点很少被意识到.
    
内存对齐
    结构体对齐是其成员最大值对齐值
    结构对齐一种说法        //来自https://www.zhihu.com/question/27862634?sort=created
        内存对齐主要遵循下面三个原则:
            结构体变量的起始地址能够被其最宽的成员大小整除
            结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充字节
            结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节
        例如:
            struct A{
                char a;
                int b;
                short c;
            }
        对齐后sizeof(A)为12字节
    另一种说法       //来自https://zhuanlan.zhihu.com/p/30007037
        了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：
            (1) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。
            (2) 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。
